Instruction pour le compil: ./compil.sh nameLex.l nameYacc


TODO:
-gestions des STRUCTURES !


-finir declarations variables temporaires pour les blocs (boucle, if ...)
-entree sortie de bloc => faire productions pour push et pop les TS de la pile
-changer la fonction du sizeof (pour calculer directement)
-gestion du void*, qui permet d'accepter simplement n'importe quel type de pointeur !
-garder le type du return d'une fonction??



ERREURS GRAVES : 
TOUJOURS CES PUTAINS DE TYPAGES AVEC LES POINTEURS SUR FONCTIONS DE MORT

A DEMANDER :




NOUS SOMMES PERPLEXE:
sizeof ~~~~~~~~~
le free pour la concatenation






Reflexions sur les structures:



struct liste {
  int valeur;
  struct liste *suivant;
};

on enregistre liste comme etant une structure (dans la table des symboles) avec un champs valeur (type int) et un champ suivant (type ptr)




p est une structure liste

p->suivant=malloc(sizeof(p));

p->valeur ~=~ (*p).valeur ~=~ *(p)
p->suivant ~=~ (*p).suivant ~=~ *(p+sizeof(type(valeur)))




structures= [champs1, champs2, champs3...] = *champs
champs = *nom+*type


il faut ecrire une fonction size_if_type qui genere la somme des size des champs


imaginons une structure s dont les 3 champs sont de type int
on a cette "Ã©quivalence" s->champs3 = *(s+size_of_type(champs1)+size_of_type(champs2))
en pratique, on veut generer ce code = *s+sizeof(int)+sizeof(int)
























typedef enum {int_t, void_t, ptr_int_t), struct(type_t1, type_t2...), error} type_t ;



type_t ptr(t type_t) -> ajoute un nouveau Ã  type_t
fct(type_depart, type_arrive)


int f(int, int, int*)    int x int x ptr(int) -> int

f(1,2,p,4) int x int x ptr(int) x int

int *add(int a, int b);

type(add)= int x int -> int*



s= add(1,2)


foo(t1, t2, t3)


type(foo)= t1xt2xt3 -> tau






nom	| type
________|___________________
add	| int x int -> int*



int *ptr;









int f





int main()
{

int f();

return 0;
}




















