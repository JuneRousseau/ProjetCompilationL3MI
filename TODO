Instruction pour le compil: ./compil.sh nameLex.l nameYacc


TODO:
-gestions des STRUCTURES !




ERREURS GRAVES : 
TOUJOURS CES TYPAGES AVEC LES POINTEURS SUR FONCTIONS DE MORT
Quand on compare les arbres de type, on sait pas forcement si il s'agit de types "primitifs" ou de structure (il faudrait etre capable de le detecter)


A DEMANDER :




NOUS SOMMES PERPLEXE:
sizeof ~~~~~~~~~
le free pour la concatenation
Il y a probablement un memory leak sur la suppression de table des symbole -> voir comment liberer la table
le type de retour de la fonction (le type de return?) lors de la definition de fonction




Reflexions sur les structures:



struct liste {
  int valeur;
  struct liste *suivant;
};

on enregistre liste comme etant une structure (dans la table des symboles) avec un champs valeur (type int) et un champ suivant (type ptr)




p est une structure liste

p->suivant=malloc(sizeof(p));

p->valeur ~=~ (*p).valeur ~=~ *(p)
p->suivant ~=~ (*p).suivant ~=~ *(p+sizeof(type(valeur)))




structures= [champs1, champs2, champs3...] = *champs
champs = *nom+*type


il faut ecrire une fonction size_if_type qui genere la somme des size des champs


imaginons une structure s dont les 3 champs sont de type int
on a cette "Ã©quivalence" s->champs3 = *(s+size_of_type(champs1)+size_of_type(champs2))
en pratique, on veut generer ce code = *s+sizeof(int)+sizeof(int)
























typedef enum {int_t, void_t, ptr_int_t), struct(type_t1, type_t2...), error} type_t ;



type_t ptr(t type_t) -> ajoute un nouveau Ã  type_t
fct(type_depart, type_arrive)


int f(int, int, int*)    int x int x ptr(int) -> int

f(1,2,p,4) int x int x ptr(int) x int

int *add(int a, int b);

type(add)= int x int -> int*



s= add(1,2)


foo(t1, t2, t3)


type(foo)= t1xt2xt3 -> tau






nom	| type
________|___________________
add	| int x int -> int*



int *ptr;









int f





int main()
{

int f();

return 0;
}




















