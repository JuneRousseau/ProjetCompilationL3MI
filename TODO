Instruction pour le compil: ./compil.sh nameLex.l nameYacc


TODO:
-gestions des structures !

-GESTION DES TYPES/DECLARATION DES VAR TEMPORAIRES (type t_x; t_x=...)




A DEMANDER :

-nom des variables temporaires (collision avec un nom dans le programme)
-pointeur sur type_t ??
-manipulation structures avec name.champs (faut-il le supprimer de la grammaire oui ou non?)
-code généré sur le terminal ou dans un fichier?



NOUS SOMMES PERPLEXE:
sizeof ~~~~~~~~~
le free pour la concatenation







a = b = 1

a = (b = 1)

b= 1
t_1= b
a = t_1














exp1 && exp2 ...


code exp1
if $1.res goto label_suite
goto label_false


label_suite:
code exp2
if $2.res goto label_true
goto label_false

label_true:
$$.res= 1

label_false:
$$.res= 0




exp1 || exp2

code exp1
if $1.res goto label_true
goto label_suite

label_suite:
code exp2
if $2.res goto label_true
goto label_false

label_true:
$$.res= 1

label_false:
$$.res= 0



if (exp) :
 corps


if $$.res goto label_true
goto label_false

label_true:
code_corps

label_false:






t_1 = p-> suivant
t_2=sizeof(p)
t_3=malloc(t_2)                t_3 = malloc (sizeof(p))
t_1 =





p->suivant=malloc(sizeof(p));
return p->suivant;


t_1= sizeof(p)
t_2=malloc(t_1)
p->suivant=t_2
t_4= p->suivant
return t_4






a=(1+2)+3

b=a+1
c=a+b

return c


t_1=1+2
t_2=t_1+3
a=t_2

t_3=a+1
b=t_3

t_4=a+b
c=t_4

t_5= c

return t_5







p->suivant=malloc(sizeof(p));


expression 	-> postfix_exp 			"=" 	expression
		-> postfix_exp "->" ID   	"=" 	postfix_exp
		-> ID "->" ID			"=" 	postfix_exp "(" arg_list ")"
		-> ID "->" ID 			"="	ID(expression)
		






p->suivant <=> (*p).suivant




for(exp_stm1 exp_stm2 exp3) stm4

<=> 
exp_stm1 
while(exp_stm2) {stm4 exp3}


for(i=0; i<10; i++) corps


code_exp_stm1
code_exp_stm2
if (res_stm_2) goto label_loop
goto label_end

label_loop:
	code_stm4
	code_exp3
	code_exp_stm2
	if(res_code_exp_stm2) goto label_loop
	goto label_end

label_end:
	













Reflexions sur les structures:



struct liste {
  int valeur;
  struct liste *suivant;
};

on enregistre liste comme etant une structure (dans la table des symboles) avec un champs valeur (type int) et un champ suivant (type ptr)










p est une structure liste

p->suivant=malloc(sizeof(p));

p->valeur ~=~ (*p).valeur ~=~ *(p)
p->suivant ~=~ (*p).suivant ~=~ *(p+sizeof(type(valeur)))


--->

t_0= 





structures= [champs1, champs2, champs3...] = *champs
champs = *nom+*type


il faut ecrire une fonction size_if_type qui genere la somme des size des champs


imaginons une structure s dont les 3 champs sont de type int
on a cette "équivalence" s->champs3 = *(s+size_of_type(champs1)+size_of_type(champs2))
en pratique, on veut generer ce code = *s+sizeof(int)+sizeof(int)

















