Instruction pour le compil: ./compil.sh nameLex.l nameYacc


TODO:
-retrouver le type de retour de la fonction QUAND ON FAIT UN RETURN (donc connaitre le nom de la fct)
-factoriser les fonctions quand c'est possible
-comparer les structures avec les noms des champs!
-verifier que les parametres sont de type int OU pointeur UNIQUEMENT!
-verifier que les return ne renvoient QUE des int, pointeurs ou constantes UNIQUEMENT!
-verifi qu'on ne declare pas une structures toute seule (sans pointeur)
-les pointeurs de pointeurs ne sont PAS autorisés!
-verifier que les structures sotn alloués par un malloc

ERREURS GRAVES : 
Typage des pointeurs sur fonctions lors des declarations ne passent pas /!\
Quand on compare les arbres de type, on sait pas forcement si il s'agit de types "primitifs" ou de structure (il faudrait etre capable de le detecter)


A DEMANDER :




NOUS SOMMES PERPLEXE:
sizeof ~~~~~~~~~
le free pour la concatenation
definitions de structures dans differents niveau de portee




Reflexions sur les structures:



struct liste {
  int valeur;
  struct liste *suivant;
};

on enregistre liste comme etant une structure (dans la table des symboles) avec un champs valeur (type int) et un champ suivant (type ptr)




p est une structure liste

p->suivant=malloc(sizeof(p));

p->valeur ~=~ (*p).valeur ~=~ *(p)
p->suivant ~=~ (*p).suivant ~=~ *(p+sizeof(type(valeur)))




structures= [champs1, champs2, champs3...] = *champs
champs = *nom+*type


il faut ecrire une fonction size_if_type qui genere la somme des size des champs


imaginons une structure s dont les 3 champs sont de type int
on a cette "équivalence" s->champs3 = *(s+size_of_type(champs1)+size_of_type(champs2))
en pratique, on veut generer ce code = *s+sizeof(int)+sizeof(int)
























typedef enum {int_t, void_t, ptr_int_t), struct(type_t1, type_t2...), error} type_t ;



type_t ptr(t type_t) -> ajoute un nouveau à type_t
fct(type_depart, type_arrive)


int f(int, int, int*)    int x int x ptr(int) -> int

f(1,2,p,4) int x int x ptr(int) x int

int *add(int a, int b);

type(add)= int x int -> int*



s= add(1,2)


foo(t1, t2, t3)


type(foo)= t1xt2xt3 -> tau






nom	| type
________|___________________
add	| int x int -> int*



int *ptr;









int f





int main()
{

int f();

return 0;
}



struct my_struct

struct{int *p; int y;}
struct{int y; int *p} s= malloc(8);
s->y= ...
s->p= ...




int x;

struct liste {
int x;
struct liste *suivant;
}

struct liste *l;



l->x  	======>	*(l+0)
l->suivant ===>	*(l+sizeof(int))
		


$1.type (ptr_sur_struct)

PTR_T( STRUCT_T ( PROD_T(champs_1, PROD_T (champs_2, ... PROD_T(champs_n, NULL)) )









