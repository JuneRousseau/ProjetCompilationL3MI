Instruction pour le compil: ./compil.sh nameLex.l nameYacc


TODO:
-gestions des STRUCTURES !
-grammaire backend reconnaissance x y==z
-garder la taille d'une variable dans la table des symbole
-des qu'on a un pointeur, le transformer en void* (les pointeurs sont forcement des void)
-uand on fait un type produit, si on a un error_t, il faut que le type renvoyé soit un error_t (idem pour struct, fonction....)


ERREURS GRAVES : 
Typage des pointeurs sur fonctions lors des declarations ne passent pas /!\
Quand on compare les arbres de type, on sait pas forcement si il s'agit de types "primitifs" ou de structure (il faudrait etre capable de le detecter)


A DEMANDER :




NOUS SOMMES PERPLEXE:
sizeof ~~~~~~~~~
le free pour la concatenation
le type de retour de la fonction (le type de return?) lors de la definition de fonction
definitions de structures dans differents niveau de portee




Reflexions sur les structures:



struct liste {
  int valeur;
  struct liste *suivant;
};

on enregistre liste comme etant une structure (dans la table des symboles) avec un champs valeur (type int) et un champ suivant (type ptr)




p est une structure liste

p->suivant=malloc(sizeof(p));

p->valeur ~=~ (*p).valeur ~=~ *(p)
p->suivant ~=~ (*p).suivant ~=~ *(p+sizeof(type(valeur)))




structures= [champs1, champs2, champs3...] = *champs
champs = *nom+*type


il faut ecrire une fonction size_if_type qui genere la somme des size des champs


imaginons une structure s dont les 3 champs sont de type int
on a cette "équivalence" s->champs3 = *(s+size_of_type(champs1)+size_of_type(champs2))
en pratique, on veut generer ce code = *s+sizeof(int)+sizeof(int)
























typedef enum {int_t, void_t, ptr_int_t), struct(type_t1, type_t2...), error} type_t ;



type_t ptr(t type_t) -> ajoute un nouveau à type_t
fct(type_depart, type_arrive)


int f(int, int, int*)    int x int x ptr(int) -> int

f(1,2,p,4) int x int x ptr(int) x int

int *add(int a, int b);

type(add)= int x int -> int*



s= add(1,2)


foo(t1, t2, t3)


type(foo)= t1xt2xt3 -> tau






nom	| type
________|___________________
add	| int x int -> int*



int *ptr;









int f





int main()
{

int f();

return 0;
}



struct my_struct

struct{int *p; int y;}
struct{int y; int *p} s= malloc(8);
s->y= ...
s->p= ...




int x;

struct liste {
int x;
struct liste *suivant;
}

struct liste *l;



l->x  	======>	*(l+0)
l->suivant ===>	*(l+sizeof(int))
		






